def fetch_votes(votacao_id):
    url = f"{BASE}/votacoes/{votacao_id}/votos"
    r = requests.get(
        url,
        headers={"Accept": "application/json"},
        timeout=60
    )

    if r.status_code != 200:
        return []

    j = r.json()
    return j.get("dados", [])

import os
import sys
import requests
from datetime import datetime, timedelta, timezone
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models import Decision, Politician, OfficialVote

BASE = "https://dadosabertos.camara.leg.br/api/v2"

def iso_date(days_back: int):
    d = datetime.now(timezone.utc) - timedelta(days=days_back)
    return d.date().isoformat()

def get_all(url, params=None):
    params = dict(params or {})
    params.setdefault("ordem", "DESC")
    params.setdefault("itens", 100)
    page = 1
    out = []
    while True:
        params["pagina"] = page
        r = requests.get(url, params=params, timeout=60, headers={"Accept": "application/json"})
        r.raise_for_status()
        j = r.json()
        out.extend(j.get("dados", []) or [])
        links = {l.get("rel"): l.get("href") for l in (j.get("links") or [])}
        if "next" in links:
            page += 1
        else:
            break
    return out

def get_all_no_params(url):
    out = []
    next_url = url
    while next_url:
        r = requests.get(next_url, timeout=60, headers={"Accept": "application/json"})
        r.raise_for_status()
        j = r.json()
        out.extend(j.get("dados", []) or [])
        links = {l.get("rel"): l.get("href") for l in (j.get("links") or [])}
        next_url = links.get("next")
    return out

def upsert_politician(db: Session, dep):
    ext_id = str(dep["id"])
    p = db.query(Politician).filter_by(source="camara", external_id=ext_id).first()
    if not p:
        p = Politician(
            source="camara",
            external_id=ext_id,
            name=dep.get("nome", ""),
            uf=dep.get("siglaUf"),
            role="deputado_federal",
            scope="federal",
        )
        db.add(p)
        db.flush()
    return p

def upsert_decision(db: Session, vot):
    ext_id = str(vot.get("id"))
    d = db.query(Decision).filter_by(source="camara", external_id=ext_id).first()
    if not d:
        d = Decision(
            title=vot.get("descricao") or f"Votação Câmara {ext_id}",
            source="camara",
            external_id=ext_id,
            url=vot.get("uri"),
        )
        db.add(d)
        db.flush()
    return d

def map_choice(raw):
    s = (raw or "").lower()
    if s in ("sim", "s"):
        return "concordo"
    if s in ("não", "nao", "n"):
        return "discordo"
    if "absten" in s:
        return "abstencao"
    return "ausente"

def main():
    db: Session = SessionLocal()
    try:
        deps = get_all(f"{BASE}/deputados")
        dep_by_id = {}
        for dep in deps:
            p = upsert_politician(db, dep)
            dep_by_id[str(dep["id"])] = p
        db.commit()

        votacoes = get_all(
            f"{BASE}/votacoes",
            params={"dataInicio": iso_date(30), "dataFim": iso_date(0)}
        )[:50]

        for v in votacoes:
            decision = upsert_decision(db, v)
            db.commit()

            votos = get_all_no_params(f"{BASE}/votacoes/{v['id']}/votos")

            for vt in votos:
                dep_id = str(vt.get("idDeputado")) if vt.get("idDeputado") else None
                if dep_id not in dep_by_id:
                    continue
                pol = dep_by_id[dep_id]
                choice = map_choice(vt.get("voto"))
                if not db.query(OfficialVote).filter_by(
                    decision_id=decision.id,
                    politician_id=pol.id
                ).first():
                    db.add(OfficialVote(
                        decision_id=decision.id,
                        politician_id=pol.id,
                        choice=choice
                    ))
            db.commit()

        print("camara_sync: ok", flush=True)

    except Exception as e:
        print("camara_sync error:", e, file=sys.stderr, flush=True)
        raise
    finally:
        db.close()

if __name__ == "__main__":
    main()
